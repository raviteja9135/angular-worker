{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, Component, Input, TemplateRef, ComponentFactoryResolver, Directive, Pipe, NgModule, APP_INITIALIZER } from '@angular/core';\nimport { of, from, Subject, BehaviorSubject, forkJoin, combineLatest, EMPTY } from 'rxjs';\nimport { take, map, retry, tap, catchError, shareReplay, switchMap } from 'rxjs/operators';\nimport { unflatten as unflatten$1, flatten as flatten$1 } from 'flat';\nclass DefaultLoader {\n  constructor(translations) {\n    this.translations = translations;\n  }\n  getTranslation(lang) {\n    return of(this.translations.get(lang) || {});\n  }\n}\nconst TRANSLOCO_LOADER = new InjectionToken('TRANSLOCO_LOADER');\nfunction getValue(obj, path) {\n  if (!obj) {\n    return obj;\n  }\n  /* For cases where the key is like: 'general.something.thing' */\n  if (Object.prototype.hasOwnProperty.call(obj, path)) {\n    return obj[path];\n  }\n  return path.split('.').reduce((p, c) => p?.[c], obj);\n}\nfunction setValue(obj, prop, val) {\n  obj = {\n    ...obj\n  };\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : {\n        ...acc[part]\n      };\n    }\n    return acc && acc[part];\n  }, obj);\n  return obj;\n}\nfunction size(collection) {\n  if (!collection) {\n    return 0;\n  }\n  if (Array.isArray(collection)) {\n    return collection.length;\n  }\n  if (isObject(collection)) {\n    return Object.keys(collection).length;\n  }\n  return collection ? collection.length : 0;\n}\nfunction isEmpty(collection) {\n  return size(collection) === 0;\n}\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\nfunction isString(val) {\n  return typeof val === 'string';\n}\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\nfunction isObject(item) {\n  return !!item && typeof item === 'object' && !Array.isArray(item);\n}\nfunction coerceArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\nfunction toCamelCase(str) {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => index == 0 ? word.toLowerCase() : word.toUpperCase()).replace(/\\s+|_|-|\\//g, '');\n}\nfunction isBrowser() {\n  return typeof window !== 'undefined';\n}\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\nfunction isDefined(value) {\n  return isNil(value) === false;\n}\nfunction toNumber(value) {\n  if (isNumber(value)) return value;\n  if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n    return Number(value);\n  }\n  return null;\n}\nfunction isScopeObject(item) {\n  return item && typeof item.scope === 'string';\n}\nfunction hasInlineLoader(item) {\n  return item && isObject(item.loader);\n}\nfunction unflatten(obj) {\n  return unflatten$1(obj);\n}\nfunction flatten(obj) {\n  return flatten$1(obj, {\n    safe: true\n  });\n}\nconst TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n  providedIn: 'root',\n  factory: () => {\n    return {\n      defaultLang: 'en'\n    };\n  }\n});\nconst defaultConfig = {\n  defaultLang: 'en',\n  reRenderOnLangChange: false,\n  prodMode: false,\n  failedRetries: 2,\n  availableLangs: [],\n  missingHandler: {\n    logMissingKey: true,\n    useFallbackTranslation: false,\n    allowEmpty: false\n  },\n  flatten: {\n    aot: false\n  },\n  interpolation: ['{{', '}}']\n};\n/**\n * Sets up TranslocoConfig object.\n *\n * @param config The partial config object to load, this is optional,\n * will be spread after defaultConfig.\n */\nfunction translocoConfig(config = defaultConfig) {\n  return {\n    ...defaultConfig,\n    ...config\n  };\n}\nconst TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\nclass DefaultTranspiler {\n  constructor(userConfig) {\n    this.interpolationMatcher = resolveMatcher(userConfig);\n  }\n  transpile(value, params = {}, translation, key) {\n    if (isString(value)) {\n      return value.replace(this.interpolationMatcher, (_, match) => {\n        match = match.trim();\n        if (isDefined(params[match])) {\n          return params[match];\n        }\n        return isDefined(translation[match]) ? this.transpile(translation[match], params, translation, key) : '';\n      });\n    } else if (params) {\n      if (isObject(value)) {\n        value = this.handleObject(value, params, translation, key);\n      } else if (Array.isArray(value)) {\n        value = this.handleArray(value, params, translation, key);\n      }\n    }\n    return value;\n  }\n  /**\n   *\n   * @example\n   *\n   * const en = {\n   *  a: {\n   *    b: {\n   *      c: \"Hello {{ value }}\"\n   *    }\n   *  }\n   * }\n   *\n   * const params =  {\n   *  \"b.c\": { value: \"Transloco \"}\n   * }\n   *\n   * service.selectTranslate('a', params);\n   *\n   * // the first param will be the result of `en.a`.\n   * // the second param will be `params`.\n   * parser.transpile(value, params, {});\n   *\n   *\n   */\n  handleObject(value, params = {}, translation, key) {\n    let result = value;\n    Object.keys(params).forEach(p => {\n      // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n      const v = getValue(result, p);\n      // get the params of \"b.c\" => { value: \"Transloco\" }\n      const getParams = getValue(params, p);\n      // transpile the value => \"Hello Transloco\"\n      const transpiled = this.transpile(v, getParams, translation, key);\n      // set \"b.c\" to `transpiled`\n      result = setValue(result, p, transpiled);\n    });\n    return result;\n  }\n  handleArray(value, params = {}, translation, key) {\n    return value.map(v => this.transpile(v, params, translation, key));\n  }\n}\nDefaultTranspiler.ɵfac = function DefaultTranspiler_Factory(t) {\n  return new (t || DefaultTranspiler)(i0.ɵɵinject(TRANSLOCO_CONFIG, 8));\n};\nDefaultTranspiler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultTranspiler,\n  factory: DefaultTranspiler.ɵfac\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultTranspiler, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_CONFIG]\n      }]\n    }];\n  }, null);\n})();\nfunction resolveMatcher(userConfig) {\n  const [start, end] = userConfig && userConfig.interpolation ? userConfig.interpolation : defaultConfig.interpolation;\n  return new RegExp(`${start}(.*?)${end}`, 'g');\n}\nfunction getFunctionArgs(argsString) {\n  const splitted = argsString ? argsString.split(',') : [];\n  const args = [];\n  for (let i = 0; i < splitted.length; i++) {\n    let value = splitted[i].trim();\n    while (value[value.length - 1] === '\\\\') {\n      i++;\n      value = value.replace('\\\\', ',') + splitted[i];\n    }\n    args.push(value);\n  }\n  return args;\n}\nclass FunctionalTranspiler extends DefaultTranspiler {\n  constructor(injector) {\n    super();\n    this.injector = injector;\n  }\n  transpile(value, params = {}, translation, key) {\n    let transpiled = value;\n    if (isString(value)) {\n      transpiled = value.replace(/\\[\\[\\s*(\\w+)\\((.*)\\)\\s*]]/g, (match, functionName, args) => {\n        try {\n          const func = this.injector.get(functionName);\n          return func.transpile(...getFunctionArgs(args));\n        } catch (e) {\n          let message = `There is an error in: '${value}'. \n                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;\n          if (e.message.includes('NullInjectorError')) {\n            message = `You are using the '${functionName}' function in your translation but no provider was found!`;\n          }\n          throw new Error(message);\n        }\n      });\n    }\n    return super.transpile(transpiled, params, translation, key);\n  }\n}\nFunctionalTranspiler.ɵfac = function FunctionalTranspiler_Factory(t) {\n  return new (t || FunctionalTranspiler)(i0.ɵɵinject(i0.Injector));\n};\nFunctionalTranspiler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FunctionalTranspiler,\n  factory: FunctionalTranspiler.ɵfac\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FunctionalTranspiler, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i0.Injector\n    }];\n  }, null);\n})();\nconst TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\nclass DefaultHandler {\n  handle(key, config) {\n    if (config.missingHandler.logMissingKey && !config.prodMode) {\n      const msg = `Missing translation for '${key}'`;\n      console.warn(`%c ${msg}`, 'font-size: 12px; color: red');\n    }\n    return key;\n  }\n}\nDefaultHandler.ɵfac = function DefaultHandler_Factory(t) {\n  return new (t || DefaultHandler)();\n};\nDefaultHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultHandler,\n  factory: DefaultHandler.ɵfac\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultHandler, [{\n    type: Injectable\n  }], null, null);\n})();\nconst TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\nclass DefaultInterceptor {\n  preSaveTranslation(translation) {\n    return translation;\n  }\n  preSaveTranslationKey(_, value) {\n    return value;\n  }\n}\nDefaultInterceptor.ɵfac = function DefaultInterceptor_Factory(t) {\n  return new (t || DefaultInterceptor)();\n};\nDefaultInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultInterceptor,\n  factory: DefaultInterceptor.ɵfac\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultInterceptor, [{\n    type: Injectable\n  }], null, null);\n})();\nconst TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken('TRANSLOCO_FALLBACK_STRATEGY');\nclass DefaultFallbackStrategy {\n  constructor(userConfig) {\n    this.userConfig = userConfig;\n  }\n  getNextLangs() {\n    const fallbackLang = this.userConfig.fallbackLang;\n    if (!fallbackLang) {\n      throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n    }\n    return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n  }\n}\nDefaultFallbackStrategy.ɵfac = function DefaultFallbackStrategy_Factory(t) {\n  return new (t || DefaultFallbackStrategy)(i0.ɵɵinject(TRANSLOCO_CONFIG));\n};\nDefaultFallbackStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultFallbackStrategy,\n  factory: DefaultFallbackStrategy.ɵfac\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultFallbackStrategy, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_CONFIG]\n      }]\n    }];\n  }, null);\n})();\nfunction mergeConfig(defaultConfig, userConfig) {\n  return {\n    ...defaultConfig,\n    ...userConfig,\n    missingHandler: {\n      ...defaultConfig.missingHandler,\n      ...userConfig.missingHandler\n    },\n    flatten: {\n      ...defaultConfig.flatten,\n      ...userConfig.flatten\n    }\n  };\n}\n\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\nfunction getScopeFromLang(lang) {\n  if (!lang) {\n    return '';\n  }\n  const split = lang.split('/');\n  split.pop();\n  return split.join('/');\n}\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\nfunction getLangFromScope(lang) {\n  if (!lang) {\n    return '';\n  }\n  return lang.split('/').pop();\n}\n/**\n * @example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n */\nfunction getPipeValue(str, value, char = '|') {\n  if (isString(str)) {\n    const splitted = str.split(char);\n    const lastItem = splitted.pop();\n    return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n  }\n  return [false, ''];\n}\nfunction shouldListenToLangChanges(service, lang) {\n  const [hasStatic] = getPipeValue(lang, 'static');\n  if (!hasStatic) {\n    // If we didn't get 'lang|static' check if it's set in the global level\n    return !!service.config.reRenderOnLangChange;\n  }\n  // We have 'lang|static' so don't listen to lang changes\n  return false;\n}\nfunction listenOrNotOperator(listenToLangChange) {\n  return listenToLangChange ? source => source : take(1);\n}\nfunction prependScope(inlineLoader, scope) {\n  return Object.keys(inlineLoader).reduce((acc, lang) => {\n    acc[`${scope}/${lang}`] = inlineLoader[lang];\n    return acc;\n  }, {});\n}\nfunction resolveInlineLoader(providerScope, scope) {\n  return hasInlineLoader(providerScope) ? prependScope(providerScope.loader, scope) : undefined;\n}\nfunction getEventPayload(lang) {\n  return {\n    scope: getScopeFromLang(lang) || null,\n    langName: getLangFromScope(lang)\n  };\n}\nfunction resolveLoader(options) {\n  const {\n    path,\n    inlineLoader,\n    mainLoader,\n    data\n  } = options;\n  if (inlineLoader) {\n    const pathLoader = inlineLoader[path];\n    if (isFunction(pathLoader) === false) {\n      throw `You're using an inline loader but didn't provide a loader for ${path}`;\n    }\n    return inlineLoader[path]().then(res => res.default ? res.default : res);\n  }\n  return mainLoader.getTranslation(path, data);\n}\nfunction getFallbacksLoaders({\n  mainLoader,\n  path,\n  data,\n  fallbackPath,\n  inlineLoader\n}) {\n  const paths = fallbackPath ? [path, fallbackPath] : [path];\n  return paths.map(path => {\n    const loader = resolveLoader({\n      path,\n      mainLoader,\n      inlineLoader,\n      data\n    });\n    return from(loader).pipe(map(translation => ({\n      translation,\n      lang: path\n    })));\n  });\n}\nlet service;\nfunction translate(key, params = {}, lang) {\n  return service.translate(key, params, lang);\n}\nfunction translateObject(key, params = {}, lang) {\n  return service.translateObject(key, params, lang);\n}\nclass TranslocoService {\n  constructor(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {\n    this.loader = loader;\n    this.parser = parser;\n    this.missingHandler = missingHandler;\n    this.interceptor = interceptor;\n    this.userConfig = userConfig;\n    this.fallbackStrategy = fallbackStrategy;\n    this.subscription = null;\n    this.translations = new Map();\n    this.cache = new Map();\n    this.defaultLang = '';\n    this.availableLangs = [];\n    this.isResolvedMissingOnce = false;\n    this.failedLangs = new Set();\n    this.events = new Subject();\n    this.events$ = this.events.asObservable();\n    if (!this.loader) {\n      this.loader = new DefaultLoader(this.translations);\n    }\n    service = this;\n    this.mergedConfig = mergeConfig(defaultConfig, this.userConfig);\n    this.setAvailableLangs(this.mergedConfig.availableLangs || []);\n    this.setFallbackLangForMissingTranslation(this.mergedConfig);\n    this.setDefaultLang(this.mergedConfig.defaultLang);\n    this.lang = new BehaviorSubject(this.getDefaultLang());\n    // Don't use distinctUntilChanged as we need the ability to update\n    // the value when using setTranslation or setTranslationKeys\n    this.langChanges$ = this.lang.asObservable();\n    /**\n     * When we have a failure, we want to define the next language that succeeded as the active\n     */\n    this.subscription = this.events$.subscribe(e => {\n      if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n        this.setActiveLang(e.payload.langName);\n      }\n    });\n  }\n  get config() {\n    return this.mergedConfig;\n  }\n  getDefaultLang() {\n    return this.defaultLang;\n  }\n  setDefaultLang(lang) {\n    this.defaultLang = lang;\n  }\n  getActiveLang() {\n    return this.lang.getValue();\n  }\n  setActiveLang(lang) {\n    this.parser.onLangChanged?.(lang);\n    this.lang.next(lang);\n    this.events.next({\n      type: 'langChanged',\n      payload: getEventPayload(lang)\n    });\n    return this;\n  }\n  setAvailableLangs(langs) {\n    this.availableLangs = langs;\n  }\n  /**\n   * Gets the available languages.\n   *\n   * @returns\n   * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n   * depending on how the available languages are set in your module.\n   */\n  getAvailableLangs() {\n    return this.availableLangs;\n  }\n  load(path, options = {}) {\n    const cached = this.cache.get(path);\n    if (cached) {\n      return cached;\n    }\n    let loadTranslation;\n    const isScope = this._isLangScoped(path);\n    let scope;\n    if (isScope) {\n      scope = getScopeFromLang(path);\n    }\n    const loadersOptions = {\n      path,\n      mainLoader: this.loader,\n      inlineLoader: options.inlineLoader,\n      data: isScope ? {\n        scope: scope\n      } : undefined\n    };\n    if (this.useFallbackTranslation(path)) {\n      // if the path is scope the fallback should be `scope/fallbackLang`;\n      const fallback = isScope ? `${scope}/${this.firstFallbackLang}` : this.firstFallbackLang;\n      const loaders = getFallbacksLoaders({\n        ...loadersOptions,\n        fallbackPath: fallback\n      });\n      loadTranslation = forkJoin(loaders);\n    } else {\n      const loader = resolveLoader(loadersOptions);\n      loadTranslation = from(loader);\n    }\n    const load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap(translation => {\n      if (Array.isArray(translation)) {\n        translation.forEach(t => {\n          this.handleSuccess(t.lang, t.translation);\n          // Save the fallback in cache so we'll not create a redundant request\n          if (t.lang !== path) {\n            this.cache.set(t.lang, of({}));\n          }\n        });\n        return;\n      }\n      this.handleSuccess(path, translation);\n    }), catchError(error => {\n      if (!this.mergedConfig.prodMode) {\n        console.error(`Error while trying to load \"${path}\"`, error);\n      }\n      return this.handleFailure(path, options);\n    }), shareReplay(1));\n    this.cache.set(path, load$);\n    return load$;\n  }\n  /**\n   * Gets the instant translated value of a key\n   *\n   * @example\n   *\n   * translate<string>('hello')\n   * translate('hello', { value: 'value' })\n   * translate<string[]>(['hello', 'key'])\n   * translate('hello', { }, 'en')\n   * translate('scope.someKey', { }, 'en')\n   */\n  translate(key, params = {}, lang = this.getActiveLang()) {\n    if (!key) return key;\n    const {\n      scope,\n      resolveLang\n    } = this.resolveLangAndScope(lang);\n    if (Array.isArray(key)) {\n      return key.map(k => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang));\n    }\n    key = scope ? `${scope}.${key}` : key;\n    const translation = this.getTranslation(resolveLang);\n    const value = translation[key];\n    if (!value) {\n      return this._handleMissingKey(key, value, params);\n    }\n    return this.parser.transpile(value, params, translation, key);\n  }\n  /**\n   * Gets the translated value of a key as observable\n   *\n   * @example\n   *\n   * selectTranslate<string>('hello').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n   *\n   */\n  selectTranslate(key, params, lang, _isObject = false) {\n    let inlineLoader;\n    const load = (lang, options) => this.load(lang, options).pipe(map(() => _isObject ? this.translateObject(key, params, lang) : this.translate(key, params, lang)));\n    if (isNil(lang)) {\n      return this.langChanges$.pipe(switchMap(lang => load(lang)));\n    }\n    if (isScopeObject(lang)) {\n      // it's a scope object.\n      const providerScope = lang;\n      lang = providerScope.scope;\n      inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);\n    }\n    lang = lang;\n    if (this.isLang(lang) || this.isScopeWithLang(lang)) {\n      return load(lang);\n    }\n    // it's a scope\n    const scope = lang;\n    return this.langChanges$.pipe(switchMap(lang => load(`${scope}/${lang}`, {\n      inlineLoader\n    })));\n  }\n  /**\n   * Whether the scope with lang\n   *\n   * @example\n   *\n   * todos/en => true\n   * todos => false\n   */\n  isScopeWithLang(lang) {\n    return this.isLang(getLangFromScope(lang));\n  }\n  translateObject(key, params = {}, lang = this.getActiveLang()) {\n    if (isString(key) || Array.isArray(key)) {\n      const {\n        resolveLang,\n        scope\n      } = this.resolveLangAndScope(lang);\n      if (Array.isArray(key)) {\n        return key.map(k => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang));\n      }\n      const translation = this.getTranslation(resolveLang);\n      key = scope ? `${scope}.${key}` : key;\n      const value = unflatten(this.getObjectByKey(translation, key));\n      /* If an empty object was returned we want to try and translate the key as a string and not an object */\n      return isEmpty(value) ? this.translate(key, params, lang) : this.parser.transpile(value, params, translation, key);\n    }\n    const translations = [];\n    for (const [_key, _params] of this.getEntries(key)) {\n      translations.push(this.translateObject(_key, _params, lang));\n    }\n    return translations;\n  }\n  selectTranslateObject(key, params, lang) {\n    if (isString(key) || Array.isArray(key)) {\n      return this.selectTranslate(key, params, lang, true);\n    }\n    const [[firstKey, firstParams], ...rest] = this.getEntries(key);\n    /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,\n     * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */\n    return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map(value => {\n      const translations = [value];\n      for (const [_key, _params] of rest) {\n        translations.push(this.translateObject(_key, _params, lang));\n      }\n      return translations;\n    }));\n  }\n  getTranslation(langOrScope) {\n    if (langOrScope) {\n      if (this.isLang(langOrScope)) {\n        return this.translations.get(langOrScope) || {};\n      } else {\n        // This is a scope, build the scope value from the translation object\n        const {\n          scope,\n          resolveLang\n        } = this.resolveLangAndScope(langOrScope);\n        const translation = this.translations.get(resolveLang) || {};\n        return this.getObjectByKey(translation, scope);\n      }\n    }\n    return this.translations;\n  }\n  /**\n   * Gets an object of translations for a given language\n   *\n   * @example\n   *\n   * selectTranslation().subscribe() - will return the current lang translation\n   * selectTranslation('es').subscribe()\n   * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\n   * selectTranslation('admin-page/es').subscribe()\n   */\n  selectTranslation(lang) {\n    let language$ = this.langChanges$;\n    if (lang) {\n      const scopeLangSpecified = getLangFromScope(lang) !== lang;\n      if (this.isLang(lang) || scopeLangSpecified) {\n        language$ = of(lang);\n      } else {\n        language$ = this.langChanges$.pipe(map(currentLang => `${lang}/${currentLang}`));\n      }\n    }\n    return language$.pipe(switchMap(language => this.load(language).pipe(map(() => this.getTranslation(language)))));\n  }\n  /**\n   * Sets or merge a given translation object to current lang\n   *\n   * @example\n   *\n   * setTranslation({ ... })\n   * setTranslation({ ... }, 'en')\n   * setTranslation({ ... }, 'es', { merge: false } )\n   * setTranslation({ ... }, 'todos/en', { merge: false } )\n   */\n  setTranslation(translation, lang = this.getActiveLang(), options = {}) {\n    const defaults = {\n      merge: true,\n      emitChange: true\n    };\n    const mergedOptions = {\n      ...defaults,\n      ...options\n    };\n    const scope = getScopeFromLang(lang);\n    /**\n     * If this isn't a scope we use the whole translation as is\n     * otherwise we need to flat the scope and use it\n     */\n    let flattenScopeOrTranslation = translation;\n    // Merged the scoped language into the active language\n    if (scope) {\n      const key = this.getMappedScope(scope);\n      flattenScopeOrTranslation = flatten({\n        [key]: translation\n      });\n    }\n    const currentLang = scope ? getLangFromScope(lang) : lang;\n    const mergedTranslation = {\n      ...(mergedOptions.merge && this.getTranslation(currentLang)),\n      ...flattenScopeOrTranslation\n    };\n    const flattenTranslation = this.mergedConfig.flatten.aot ? mergedTranslation : flatten(mergedTranslation);\n    const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n    this.translations.set(currentLang, withHook);\n    mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n  }\n  /**\n   * Sets translation key with given value\n   *\n   * @example\n   *\n   * setTranslationKey('key', 'value')\n   * setTranslationKey('key.nested', 'value')\n   * setTranslationKey('key.nested', 'value', 'en')\n   * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )\n   */\n  setTranslationKey(key, value,\n  // Todo: Add the lang to the options in v3\n  lang = this.getActiveLang(), options = {}) {\n    const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n    const newValue = {\n      [key]: withHook\n    };\n    this.setTranslation(newValue, lang, {\n      ...options,\n      merge: true\n    });\n  }\n  /**\n   * Sets the fallback lang for the currently active language\n   * @param fallbackLang\n   */\n  setFallbackLangForMissingTranslation({\n    fallbackLang\n  }) {\n    const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n    if (fallbackLang && this.useFallbackTranslation(lang)) {\n      this.firstFallbackLang = lang;\n    }\n  }\n  /**\n   * @internal\n   */\n  _handleMissingKey(key, value, params) {\n    if (this.config.missingHandler.allowEmpty && value === '') {\n      return '';\n    }\n    if (!this.isResolvedMissingOnce && this.useFallbackTranslation()) {\n      // We need to set it to true to prevent a loop\n      this.isResolvedMissingOnce = true;\n      const fallbackValue = this.translate(key, params, this.firstFallbackLang);\n      this.isResolvedMissingOnce = false;\n      return fallbackValue;\n    }\n    return this.missingHandler.handle(key, this.getMissingHandlerData(), params);\n  }\n  /**\n   * @internal\n   */\n  _isLangScoped(lang) {\n    return this.getAvailableLangsIds().indexOf(lang) === -1;\n  }\n  /**\n   * Checks if a given string is one of the specified available languages.\n   * @returns\n   * True if the given string is an available language.\n   * False if the given string is not an available language.\n   */\n  isLang(lang) {\n    return this.getAvailableLangsIds().indexOf(lang) !== -1;\n  }\n  /**\n   * @internal\n   *\n   * We always want to make sure the global lang is loaded\n   * before loading the scope since you can access both via the pipe/directive.\n   */\n  _loadDependencies(path, inlineLoader) {\n    const mainLang = getLangFromScope(path);\n    if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n      return combineLatest(this.load(mainLang), this.load(path, {\n        inlineLoader\n      }));\n    }\n    return this.load(path, {\n      inlineLoader\n    });\n  }\n  /**\n   * @internal\n   */\n  _completeScopeWithLang(langOrScope) {\n    if (this._isLangScoped(langOrScope) && !this.isLang(getLangFromScope(langOrScope))) {\n      return `${langOrScope}/${this.getActiveLang()}`;\n    }\n    return langOrScope;\n  }\n  /**\n   * @internal\n   */\n  _setScopeAlias(scope, alias) {\n    if (!this.mergedConfig.scopeMapping) {\n      this.mergedConfig.scopeMapping = {};\n    }\n    this.mergedConfig.scopeMapping[scope] = alias;\n  }\n  ngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n      // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n      // callback within its `destination` property, preventing classes from being GC'd.\n      this.subscription = null;\n    }\n    // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.\n    // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from\n    // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created\n    // and destroyed per each HTTP request, but any service is not getting GC'd.\n    this.cache.clear();\n  }\n  isLoadedTranslation(lang) {\n    return size(this.getTranslation(lang));\n  }\n  getAvailableLangsIds() {\n    const first = this.getAvailableLangs()[0];\n    if (isString(first)) {\n      return this.getAvailableLangs();\n    }\n    return this.getAvailableLangs().map(l => l.id);\n  }\n  getMissingHandlerData() {\n    return {\n      ...this.config,\n      activeLang: this.getActiveLang(),\n      availableLangs: this.availableLangs,\n      defaultLang: this.defaultLang\n    };\n  }\n  /**\n   * Use a fallback translation set for missing keys of the primary language\n   * This is unrelated to the fallback language (which changes the active language)\n   */\n  useFallbackTranslation(lang) {\n    return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;\n  }\n  handleSuccess(lang, translation) {\n    this.setTranslation(translation, lang, {\n      emitChange: false\n    });\n    this.events.next({\n      wasFailure: !!this.failedLangs.size,\n      type: 'translationLoadSuccess',\n      payload: getEventPayload(lang)\n    });\n    this.failedLangs.forEach(l => this.cache.delete(l));\n    this.failedLangs.clear();\n  }\n  handleFailure(lang, loadOptions) {\n    // When starting to load a first choice language, initialize\n    // the failed counter and resolve the fallback langs.\n    if (isNil(loadOptions.failedCounter)) {\n      loadOptions.failedCounter = 0;\n      if (!loadOptions.fallbackLangs) {\n        loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);\n      }\n    }\n    const splitted = lang.split('/');\n    const fallbacks = loadOptions.fallbackLangs;\n    const nextLang = fallbacks[loadOptions.failedCounter];\n    this.failedLangs.add(lang);\n    // This handles the case where a loaded fallback language is requested again\n    if (this.cache.has(nextLang)) {\n      this.handleSuccess(nextLang, this.getTranslation(nextLang));\n      return EMPTY;\n    }\n    const isFallbackLang = nextLang === splitted[splitted.length - 1];\n    if (!nextLang || isFallbackLang) {\n      let msg = `Unable to load translation and all the fallback languages`;\n      if (splitted.length > 1) {\n        msg += `, did you misspelled the scope name?`;\n      }\n      throw new Error(msg);\n    }\n    let resolveLang = nextLang;\n    // if it's scoped lang\n    if (splitted.length > 1) {\n      // We need to resolve it to:\n      // todos/langNotExists => todos/nextLang\n      splitted[splitted.length - 1] = nextLang;\n      resolveLang = splitted.join('/');\n    }\n    loadOptions.failedCounter++;\n    this.events.next({\n      type: 'translationLoadFailure',\n      payload: getEventPayload(lang)\n    });\n    return this.load(resolveLang, loadOptions);\n  }\n  getMappedScope(scope) {\n    const {\n      scopeMapping = {}\n    } = this.config;\n    return scopeMapping[scope] || toCamelCase(scope);\n  }\n  /**\n   * If lang is scope we need to check the following cases:\n   * todos/es => in this case we should take `es` as lang\n   * todos => in this case we should set the active lang as lang\n   */\n  resolveLangAndScope(lang) {\n    let resolveLang = lang;\n    let scope;\n    if (this._isLangScoped(lang)) {\n      // en for example\n      const langFromScope = getLangFromScope(lang);\n      // en is lang\n      const hasLang = this.isLang(langFromScope);\n      // take en\n      resolveLang = hasLang ? langFromScope : this.getActiveLang();\n      // find the scope\n      scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n    }\n    return {\n      scope,\n      resolveLang\n    };\n  }\n  getObjectByKey(translation, key) {\n    const result = {};\n    const prefix = `${key}.`;\n    for (const currentKey in translation) {\n      if (currentKey.startsWith(prefix)) {\n        result[currentKey.replace(prefix, '')] = translation[currentKey];\n      }\n    }\n    return result;\n  }\n  getEntries(key) {\n    return key instanceof Map ? key.entries() : Object.entries(key);\n  }\n}\nTranslocoService.ɵfac = function TranslocoService_Factory(t) {\n  return new (t || TranslocoService)(i0.ɵɵinject(TRANSLOCO_LOADER, 8), i0.ɵɵinject(TRANSLOCO_TRANSPILER), i0.ɵɵinject(TRANSLOCO_MISSING_HANDLER), i0.ɵɵinject(TRANSLOCO_INTERCEPTOR), i0.ɵɵinject(TRANSLOCO_CONFIG), i0.ɵɵinject(TRANSLOCO_FALLBACK_STRATEGY));\n};\nTranslocoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TranslocoService,\n  factory: TranslocoService.ɵfac,\n  providedIn: 'root'\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_LOADER]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_TRANSPILER]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_MISSING_HANDLER]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_INTERCEPTOR]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_CONFIG]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_FALLBACK_STRATEGY]\n      }]\n    }];\n  }, null);\n})();\nclass TranslocoLoaderComponent {}\nTranslocoLoaderComponent.ɵfac = function TranslocoLoaderComponent_Factory(t) {\n  return new (t || TranslocoLoaderComponent)();\n};\nTranslocoLoaderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: TranslocoLoaderComponent,\n  selectors: [[\"ng-component\"]],\n  inputs: {\n    html: \"html\"\n  },\n  decls: 1,\n  vars: 1,\n  consts: [[1, \"transloco-loader-template\", 3, \"innerHTML\"]],\n  template: function TranslocoLoaderComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelement(0, \"div\", 0);\n    }\n    if (rf & 2) {\n      i0.ɵɵproperty(\"innerHTML\", ctx.html, i0.ɵɵsanitizeHtml);\n    }\n  },\n  encapsulation: 2\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoLoaderComponent, [{\n    type: Component,\n    args: [{\n      template: `\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\n  `\n    }]\n  }], null, {\n    html: [{\n      type: Input\n    }]\n  });\n})();\nclass TemplateHandler {\n  constructor(view, vcr) {\n    this.view = view;\n    this.vcr = vcr;\n    this.injector = this.vcr.injector;\n  }\n  attachView() {\n    if (this.view instanceof TemplateRef) {\n      this.vcr.createEmbeddedView(this.view);\n    } else if (isString(this.view)) {\n      const componentRef = this.createComponent(TranslocoLoaderComponent);\n      componentRef.instance.html = this.view;\n      componentRef.hostView.detectChanges();\n    } else {\n      this.createComponent(this.view);\n    }\n  }\n  detachView() {\n    this.vcr.clear();\n  }\n  createComponent(cmp) {\n    const cfr = this.injector.get(ComponentFactoryResolver);\n    const factory = cfr.resolveComponentFactory(cmp);\n    return this.vcr.createComponent(factory);\n  }\n}\nconst TRANSLOCO_LANG = new InjectionToken('TRANSLOCO_LANG');\nconst TRANSLOCO_LOADING_TEMPLATE = new InjectionToken('TRANSLOCO_LOADING_TEMPLATE');\nconst TRANSLOCO_SCOPE = new InjectionToken('TRANSLOCO_SCOPE');\nclass LangResolver {\n  constructor() {\n    this.initialized = false;\n  }\n  // inline => provider => active\n  resolve({\n    inline,\n    provider,\n    active\n  }) {\n    let lang = active;\n    /**\n     * When the user changes the lang we need to update\n     * the view. Otherwise, the lang will remain the inline/provided lang\n     */\n    if (this.initialized) {\n      lang = active;\n      return lang;\n    }\n    if (provider) {\n      const [, extracted] = getPipeValue(provider, 'static');\n      lang = extracted;\n    }\n    if (inline) {\n      const [, extracted] = getPipeValue(inline, 'static');\n      lang = extracted;\n    }\n    this.initialized = true;\n    return lang;\n  }\n  /**\n   *\n   * Resolve the lang\n   *\n   * @example\n   *\n   * resolveLangBasedOnScope('todos/en') => en\n   * resolveLangBasedOnScope('en') => en\n   *\n   */\n  resolveLangBasedOnScope(lang) {\n    const scope = getScopeFromLang(lang);\n    return scope ? getLangFromScope(lang) : lang;\n  }\n  /**\n   *\n   * Resolve the lang path for loading\n   *\n   * @example\n   *\n   * resolveLangPath('todos', 'en') => todos/en\n   * resolveLangPath('en') => en\n   *\n   */\n  resolveLangPath(lang, scope) {\n    return scope ? `${scope}/${lang}` : lang;\n  }\n}\nclass ScopeResolver {\n  constructor(translocoService) {\n    this.translocoService = translocoService;\n  }\n  // inline => provider\n  resolve({\n    inline,\n    provider\n  } = {\n    inline: undefined,\n    provider: undefined\n  }) {\n    if (inline) {\n      return inline;\n    }\n    if (provider) {\n      if (isScopeObject(provider)) {\n        const {\n          scope,\n          alias = toCamelCase(scope)\n        } = provider;\n        this.translocoService._setScopeAlias(scope, alias);\n        return scope;\n      }\n      return provider;\n    }\n    return undefined;\n  }\n}\nclass TranslocoDirective {\n  constructor(translocoService, tpl, providerScope, providerLang, providedLoadingTpl, vcr, cdr, host, renderer) {\n    this.translocoService = translocoService;\n    this.tpl = tpl;\n    this.providerScope = providerScope;\n    this.providerLang = providerLang;\n    this.providedLoadingTpl = providedLoadingTpl;\n    this.vcr = vcr;\n    this.cdr = cdr;\n    this.host = host;\n    this.renderer = renderer;\n    this.subscription = null;\n    this.translationMemo = {};\n    this.params = {};\n    // Whether we already rendered the view once\n    this.initialized = false;\n    this.langResolver = new LangResolver();\n    this.scopeResolver = new ScopeResolver(this.translocoService);\n    this.strategy = this.tpl === null ? 'attribute' : 'structural';\n  }\n  static ngTemplateContextGuard(dir, ctx) {\n    return true;\n  }\n  ngOnInit() {\n    const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);\n    this.subscription = this.translocoService.langChanges$.pipe(switchMap(activeLang => {\n      const lang = this.langResolver.resolve({\n        inline: this.inlineLang,\n        provider: this.providerLang,\n        active: activeLang\n      });\n      return Array.isArray(this.providerScope) ? forkJoin(this.providerScope.map(providerScope => this.resolveScope(lang, providerScope))) : this.resolveScope(lang, this.providerScope);\n    }), listenOrNotOperator(listenToLangChange)).subscribe(() => {\n      this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);\n      this.strategy === 'attribute' ? this.attributeStrategy() : this.structuralStrategy(this.currentLang, this.inlineRead);\n      this.cdr.markForCheck();\n      this.initialized = true;\n    });\n    const loadingTpl = this.getLoadingTpl();\n    if (!this.initialized && loadingTpl) {\n      this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);\n      this.loaderTplHandler.attachView();\n    }\n  }\n  ngOnChanges(changes) {\n    // We need to support dynamic keys/params, so if this is not the first change CD cycle\n    // we need to run the function again in order to update the value\n    if (this.strategy === 'attribute') {\n      const notInit = Object.keys(changes).some(v => !changes[v].firstChange);\n      notInit && this.attributeStrategy();\n    }\n  }\n  attributeStrategy() {\n    this.detachLoader();\n    this.renderer.setProperty(this.host.nativeElement, 'innerText', this.translocoService.translate(this.key, this.params, this.currentLang));\n  }\n  structuralStrategy(lang, read) {\n    this.translationMemo = {};\n    if (this.view) {\n      // when the lang changes we need to change the reference so Angular will update the view\n      this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n      this.view.context['currentLang'] = this.currentLang;\n    } else {\n      this.detachLoader();\n      this.view = this.vcr.createEmbeddedView(this.tpl, {\n        $implicit: this.getTranslateFn(lang, read),\n        currentLang: this.currentLang\n      });\n    }\n  }\n  getTranslateFn(lang, read) {\n    return (key, params) => {\n      const withRead = read ? `${read}.${key}` : key;\n      const withParams = params ? `${withRead}${JSON.stringify(params)}` : withRead;\n      if (Object.prototype.hasOwnProperty.call(this.translationMemo, withParams)) {\n        return this.translationMemo[withParams].value;\n      }\n      this.translationMemo[withParams] = {\n        params,\n        value: this.translocoService.translate(withRead, params, lang)\n      };\n      return this.translationMemo[withParams].value;\n    };\n  }\n  getLoadingTpl() {\n    return this.inlineTpl || this.providedLoadingTpl;\n  }\n  ngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n      // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n      // callback within its `destination` property, preventing classes from being GC'd.\n      this.subscription = null;\n    }\n  }\n  detachLoader() {\n    this.loaderTplHandler?.detachView();\n  }\n  resolveScope(lang, providerScope) {\n    const resolvedScope = this.scopeResolver.resolve({\n      inline: this.inlineScope,\n      provider: providerScope\n    });\n    this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n    const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n    return this.translocoService._loadDependencies(this.path, inlineLoader);\n  }\n}\nTranslocoDirective.ɵfac = function TranslocoDirective_Factory(t) {\n  return new (t || TranslocoDirective)(i0.ɵɵdirectiveInject(TranslocoService), i0.ɵɵdirectiveInject(i0.TemplateRef, 8), i0.ɵɵdirectiveInject(TRANSLOCO_SCOPE, 8), i0.ɵɵdirectiveInject(TRANSLOCO_LANG, 8), i0.ɵɵdirectiveInject(TRANSLOCO_LOADING_TEMPLATE, 8), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n};\nTranslocoDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: TranslocoDirective,\n  selectors: [[\"\", \"transloco\", \"\"]],\n  inputs: {\n    key: [\"transloco\", \"key\"],\n    params: [\"translocoParams\", \"params\"],\n    inlineScope: [\"translocoScope\", \"inlineScope\"],\n    inlineRead: [\"translocoRead\", \"inlineRead\"],\n    inlineLang: [\"translocoLang\", \"inlineLang\"],\n    inlineTpl: [\"translocoLoadingTpl\", \"inlineTpl\"]\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[transloco]'\n    }]\n  }], function () {\n    return [{\n      type: TranslocoService\n    }, {\n      type: i0.TemplateRef,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_SCOPE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_LANG]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_LOADING_TEMPLATE]\n      }]\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i0.Renderer2\n    }];\n  }, {\n    key: [{\n      type: Input,\n      args: ['transloco']\n    }],\n    params: [{\n      type: Input,\n      args: ['translocoParams']\n    }],\n    inlineScope: [{\n      type: Input,\n      args: ['translocoScope']\n    }],\n    inlineRead: [{\n      type: Input,\n      args: ['translocoRead']\n    }],\n    inlineLang: [{\n      type: Input,\n      args: ['translocoLang']\n    }],\n    inlineTpl: [{\n      type: Input,\n      args: ['translocoLoadingTpl']\n    }]\n  });\n})();\nclass TranslocoPipe {\n  constructor(translocoService, providerScope, providerLang, cdr) {\n    this.translocoService = translocoService;\n    this.providerScope = providerScope;\n    this.providerLang = providerLang;\n    this.cdr = cdr;\n    this.subscription = null;\n    this.lastValue = '';\n    this.langResolver = new LangResolver();\n    this.scopeResolver = new ScopeResolver(this.translocoService);\n  }\n  // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311\n  // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488\n  transform(key, params, inlineLang) {\n    if (!key) {\n      return key;\n    }\n    const keyName = params ? `${key}${JSON.stringify(params)}` : key;\n    if (keyName === this.lastKey) {\n      return this.lastValue;\n    }\n    this.lastKey = keyName;\n    this.subscription?.unsubscribe();\n    const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || inlineLang);\n    this.subscription = this.translocoService.langChanges$.pipe(switchMap(activeLang => {\n      const lang = this.langResolver.resolve({\n        inline: inlineLang,\n        provider: this.providerLang,\n        active: activeLang\n      });\n      return Array.isArray(this.providerScope) ? forkJoin(this.providerScope.map(providerScope => this.resolveScope(lang, providerScope))) : this.resolveScope(lang, this.providerScope);\n    }), listenOrNotOperator(listenToLangChange)).subscribe(() => this.updateValue(key, params));\n    return this.lastValue;\n  }\n  ngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n      // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n      // callback within its `destination` property, preventing classes from being GC'd.\n      this.subscription = null;\n    }\n  }\n  updateValue(key, params) {\n    const lang = this.langResolver.resolveLangBasedOnScope(this.path);\n    this.lastValue = this.translocoService.translate(key, params, lang);\n    this.cdr.markForCheck();\n  }\n  resolveScope(lang, providerScope) {\n    const resolvedScope = this.scopeResolver.resolve({\n      inline: undefined,\n      provider: providerScope\n    });\n    this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n    const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n    return this.translocoService._loadDependencies(this.path, inlineLoader);\n  }\n}\nTranslocoPipe.ɵfac = function TranslocoPipe_Factory(t) {\n  return new (t || TranslocoPipe)(i0.ɵɵdirectiveInject(TranslocoService, 16), i0.ɵɵdirectiveInject(TRANSLOCO_SCOPE, 24), i0.ɵɵdirectiveInject(TRANSLOCO_LANG, 24), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16));\n};\nTranslocoPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n  name: \"transloco\",\n  type: TranslocoPipe,\n  pure: false\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoPipe, [{\n    type: Pipe,\n    args: [{\n      name: 'transloco',\n      pure: false\n    }]\n  }], function () {\n    return [{\n      type: TranslocoService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_SCOPE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TRANSLOCO_LANG]\n      }]\n    }, {\n      type: i0.ChangeDetectorRef\n    }];\n  }, null);\n})();\nconst defaultProviders = [{\n  provide: TRANSLOCO_TRANSPILER,\n  useClass: DefaultTranspiler,\n  deps: [TRANSLOCO_CONFIG]\n}, {\n  provide: TRANSLOCO_MISSING_HANDLER,\n  useClass: DefaultHandler\n}, {\n  provide: TRANSLOCO_INTERCEPTOR,\n  useClass: DefaultInterceptor\n}, {\n  provide: TRANSLOCO_FALLBACK_STRATEGY,\n  useClass: DefaultFallbackStrategy,\n  deps: [TRANSLOCO_CONFIG]\n}];\nclass TranslocoModule {}\nTranslocoModule.ɵfac = function TranslocoModule_Factory(t) {\n  return new (t || TranslocoModule)();\n};\nTranslocoModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: TranslocoModule\n});\nTranslocoModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [defaultProviders]\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent],\n      providers: [defaultProviders],\n      exports: [TranslocoDirective, TranslocoPipe]\n    }]\n  }], null, null);\n})();\nconst TRANSLOCO_TEST_LANGS = new InjectionToken('TRANSLOCO_TEST_LANGS - Available testing languages');\nconst TRANSLOCO_TEST_OPTIONS = new InjectionToken('TRANSLOCO_TEST_OPTIONS - Testing options');\nclass TestingLoader {\n  constructor(langs) {\n    this.langs = langs;\n  }\n  getTranslation(lang) {\n    return of(this.langs[lang]);\n  }\n}\nTestingLoader.ɵfac = function TestingLoader_Factory(t) {\n  return new (t || TestingLoader)(i0.ɵɵinject(TRANSLOCO_TEST_LANGS));\n};\nTestingLoader.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TestingLoader,\n  factory: TestingLoader.ɵfac\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TestingLoader, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TRANSLOCO_TEST_LANGS]\n      }]\n    }];\n  }, null);\n})();\nfunction initTranslocoService(service, langs = {}, options) {\n  const preloadAllLangs = () => options.preloadLangs ? Promise.all(Object.keys(langs).map(lang => service.load(lang).toPromise())) : Promise.resolve();\n  return preloadAllLangs;\n}\nclass TranslocoTestingModule {\n  static forRoot(options) {\n    return {\n      ngModule: TranslocoTestingModule,\n      providers: [{\n        provide: TRANSLOCO_TEST_LANGS,\n        useValue: options.langs\n      }, {\n        provide: TRANSLOCO_TEST_OPTIONS,\n        useValue: options\n      }, {\n        provide: APP_INITIALIZER,\n        useFactory: initTranslocoService,\n        deps: [TranslocoService, TRANSLOCO_TEST_LANGS, TRANSLOCO_TEST_OPTIONS],\n        multi: true\n      }, {\n        provide: TRANSLOCO_LOADER,\n        useClass: TestingLoader\n      }, defaultProviders, {\n        provide: TRANSLOCO_CONFIG,\n        useValue: translocoConfig({\n          prodMode: true,\n          missingHandler: {\n            logMissingKey: false\n          },\n          ...options.translocoConfig\n        })\n      }]\n    };\n  }\n}\nTranslocoTestingModule.ɵfac = function TranslocoTestingModule_Factory(t) {\n  return new (t || TranslocoTestingModule)();\n};\nTranslocoTestingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: TranslocoTestingModule\n});\nTranslocoTestingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [TranslocoModule]\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TranslocoTestingModule, [{\n    type: NgModule,\n    args: [{\n      exports: [TranslocoModule]\n    }]\n  }], null, null);\n})();\n\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n */\nfunction getBrowserLang() {\n  let browserLang = getBrowserCultureLang();\n  if (!browserLang || !isBrowser()) {\n    return undefined;\n  }\n  if (browserLang.indexOf('-') !== -1) {\n    browserLang = browserLang.split('-')[0];\n  }\n  if (browserLang.indexOf('_') !== -1) {\n    browserLang = browserLang.split('_')[0];\n  }\n  return browserLang;\n}\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n */\nfunction getBrowserCultureLang() {\n  if (!isBrowser()) {\n    return '';\n  }\n  const navigator = window.navigator;\n  let browserCultureLang = navigator.languages ? navigator.languages[0] : null;\n  browserCultureLang = browserCultureLang || navigator.language || navigator.browserLanguage || navigator.userLanguage;\n  return browserCultureLang;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DefaultFallbackStrategy, DefaultTranspiler, FunctionalTranspiler, TRANSLOCO_CONFIG, TRANSLOCO_FALLBACK_STRATEGY, TRANSLOCO_INTERCEPTOR, TRANSLOCO_LANG, TRANSLOCO_LOADER, TRANSLOCO_LOADING_TEMPLATE, TRANSLOCO_MISSING_HANDLER, TRANSLOCO_SCOPE, TRANSLOCO_TRANSPILER, TemplateHandler, TestingLoader, TranslocoDirective, TranslocoModule, TranslocoPipe, TranslocoService, TranslocoTestingModule, coerceArray, defaultConfig, defaultProviders, flatten, getBrowserCultureLang, getBrowserLang, getFunctionArgs, getLangFromScope, getPipeValue, getScopeFromLang, getValue, hasInlineLoader, isBrowser, isDefined, isEmpty, isFunction, isNil, isNumber, isObject, isScopeObject, isString, setValue, size, toCamelCase, toNumber, translate, translateObject, translocoConfig, unflatten };","map":{"version":3,"names":["i0","InjectionToken","Injectable","Optional","Inject","Component","Input","TemplateRef","ComponentFactoryResolver","Directive","Pipe","NgModule","APP_INITIALIZER","of","from","Subject","BehaviorSubject","forkJoin","combineLatest","EMPTY","take","map","retry","tap","catchError","shareReplay","switchMap","unflatten","unflatten$1","flatten","flatten$1","DefaultLoader","constructor","translations","getTranslation","lang","get","TRANSLOCO_LOADER","getValue","obj","path","Object","prototype","hasOwnProperty","call","split","reduce","p","c","setValue","prop","val","lastIndex","length","acc","part","index","Array","isArray","slice","size","collection","isObject","keys","isEmpty","isFunction","isString","isNumber","item","coerceArray","value","toCamelCase","str","replace","word","toLowerCase","toUpperCase","isBrowser","window","isNil","undefined","isDefined","toNumber","isNaN","Number","parseFloat","isScopeObject","scope","hasInlineLoader","loader","safe","TRANSLOCO_CONFIG","providedIn","factory","defaultLang","defaultConfig","reRenderOnLangChange","prodMode","failedRetries","availableLangs","missingHandler","logMissingKey","useFallbackTranslation","allowEmpty","aot","interpolation","translocoConfig","config","TRANSLOCO_TRANSPILER","DefaultTranspiler","userConfig","interpolationMatcher","resolveMatcher","transpile","params","translation","key","_","match","trim","handleObject","handleArray","result","forEach","v","getParams","transpiled","ɵfac","DefaultTranspiler_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","ngDevMode","ɵsetClassMetadata","type","decorators","args","start","end","RegExp","getFunctionArgs","argsString","splitted","i","push","FunctionalTranspiler","injector","functionName","func","e","message","includes","Error","FunctionalTranspiler_Factory","Injector","TRANSLOCO_MISSING_HANDLER","DefaultHandler","handle","msg","console","warn","DefaultHandler_Factory","TRANSLOCO_INTERCEPTOR","DefaultInterceptor","preSaveTranslation","preSaveTranslationKey","DefaultInterceptor_Factory","TRANSLOCO_FALLBACK_STRATEGY","DefaultFallbackStrategy","getNextLangs","fallbackLang","DefaultFallbackStrategy_Factory","mergeConfig","getScopeFromLang","pop","join","getLangFromScope","getPipeValue","char","lastItem","toString","shouldListenToLangChanges","service","hasStatic","listenOrNotOperator","listenToLangChange","source","prependScope","inlineLoader","resolveInlineLoader","providerScope","getEventPayload","langName","resolveLoader","options","mainLoader","data","pathLoader","then","res","default","getFallbacksLoaders","fallbackPath","paths","pipe","translate","translateObject","TranslocoService","parser","interceptor","fallbackStrategy","subscription","Map","cache","isResolvedMissingOnce","failedLangs","Set","events","events$","asObservable","mergedConfig","setAvailableLangs","setFallbackLangForMissingTranslation","setDefaultLang","getDefaultLang","langChanges$","subscribe","wasFailure","setActiveLang","payload","getActiveLang","onLangChanged","next","langs","getAvailableLangs","load","cached","loadTranslation","isScope","_isLangScoped","loadersOptions","fallback","firstFallbackLang","loaders","load$","handleSuccess","set","error","handleFailure","resolveLang","resolveLangAndScope","k","_handleMissingKey","selectTranslate","_isObject","isLang","isScopeWithLang","getObjectByKey","_key","_params","getEntries","selectTranslateObject","firstKey","firstParams","rest","langOrScope","selectTranslation","language$","scopeLangSpecified","currentLang","language","setTranslation","defaults","merge","emitChange","mergedOptions","flattenScopeOrTranslation","getMappedScope","mergedTranslation","flattenTranslation","withHook","setTranslationKey","newValue","fallbackValue","getMissingHandlerData","getAvailableLangsIds","indexOf","_loadDependencies","mainLang","isLoadedTranslation","_completeScopeWithLang","_setScopeAlias","alias","scopeMapping","ngOnDestroy","unsubscribe","clear","first","l","id","activeLang","delete","loadOptions","failedCounter","fallbackLangs","fallbacks","nextLang","add","has","isFallbackLang","langFromScope","hasLang","prefix","currentKey","startsWith","entries","TranslocoService_Factory","TranslocoLoaderComponent","TranslocoLoaderComponent_Factory","ɵcmp","ɵɵdefineComponent","selectors","inputs","html","decls","vars","consts","template","TranslocoLoaderComponent_Template","rf","ctx","ɵɵelement","ɵɵproperty","ɵɵsanitizeHtml","encapsulation","TemplateHandler","view","vcr","attachView","createEmbeddedView","componentRef","createComponent","instance","hostView","detectChanges","detachView","cmp","cfr","resolveComponentFactory","TRANSLOCO_LANG","TRANSLOCO_LOADING_TEMPLATE","TRANSLOCO_SCOPE","LangResolver","initialized","resolve","inline","provider","active","extracted","resolveLangBasedOnScope","resolveLangPath","ScopeResolver","translocoService","TranslocoDirective","tpl","providerLang","providedLoadingTpl","cdr","host","renderer","translationMemo","langResolver","scopeResolver","strategy","ngTemplateContextGuard","dir","ngOnInit","inlineLang","resolveScope","attributeStrategy","structuralStrategy","inlineRead","markForCheck","loadingTpl","getLoadingTpl","loaderTplHandler","ngOnChanges","changes","notInit","some","firstChange","detachLoader","setProperty","nativeElement","read","context","getTranslateFn","$implicit","withRead","withParams","JSON","stringify","inlineTpl","resolvedScope","inlineScope","TranslocoDirective_Factory","ɵɵdirectiveInject","ViewContainerRef","ChangeDetectorRef","ElementRef","Renderer2","ɵdir","ɵɵdefineDirective","features","ɵɵNgOnChangesFeature","selector","TranslocoPipe","lastValue","transform","keyName","lastKey","updateValue","TranslocoPipe_Factory","ɵpipe","ɵɵdefinePipe","name","pure","defaultProviders","provide","useClass","deps","TranslocoModule","TranslocoModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","providers","declarations","exports","TRANSLOCO_TEST_LANGS","TRANSLOCO_TEST_OPTIONS","TestingLoader","TestingLoader_Factory","initTranslocoService","preloadAllLangs","preloadLangs","Promise","all","toPromise","TranslocoTestingModule","forRoot","ngModule","useValue","useFactory","multi","TranslocoTestingModule_Factory","imports","getBrowserLang","browserLang","getBrowserCultureLang","navigator","browserCultureLang","languages","browserLanguage","userLanguage"],"sources":["/Users/ravi/Documents/angular-worker/node_modules/@ngneat/transloco/fesm2020/ngneat-transloco.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, Component, Input, TemplateRef, ComponentFactoryResolver, Directive, Pipe, NgModule, APP_INITIALIZER } from '@angular/core';\nimport { of, from, Subject, BehaviorSubject, forkJoin, combineLatest, EMPTY } from 'rxjs';\nimport { take, map, retry, tap, catchError, shareReplay, switchMap } from 'rxjs/operators';\nimport { unflatten as unflatten$1, flatten as flatten$1 } from 'flat';\n\nclass DefaultLoader {\n    constructor(translations) {\n        this.translations = translations;\n    }\n    getTranslation(lang) {\n        return of(this.translations.get(lang) || {});\n    }\n}\nconst TRANSLOCO_LOADER = new InjectionToken('TRANSLOCO_LOADER');\n\nfunction getValue(obj, path) {\n    if (!obj) {\n        return obj;\n    }\n    /* For cases where the key is like: 'general.something.thing' */\n    if (Object.prototype.hasOwnProperty.call(obj, path)) {\n        return obj[path];\n    }\n    return path.split('.').reduce((p, c) => p?.[c], obj);\n}\nfunction setValue(obj, prop, val) {\n    obj = { ...obj };\n    const split = prop.split('.');\n    const lastIndex = split.length - 1;\n    split.reduce((acc, part, index) => {\n        if (index === lastIndex) {\n            acc[part] = val;\n        }\n        else {\n            acc[part] = Array.isArray(acc[part])\n                ? acc[part].slice()\n                : { ...acc[part] };\n        }\n        return acc && acc[part];\n    }, obj);\n    return obj;\n}\nfunction size(collection) {\n    if (!collection) {\n        return 0;\n    }\n    if (Array.isArray(collection)) {\n        return collection.length;\n    }\n    if (isObject(collection)) {\n        return Object.keys(collection).length;\n    }\n    return collection ? collection.length : 0;\n}\nfunction isEmpty(collection) {\n    return size(collection) === 0;\n}\nfunction isFunction(val) {\n    return typeof val === 'function';\n}\nfunction isString(val) {\n    return typeof val === 'string';\n}\nfunction isNumber(val) {\n    return typeof val === 'number';\n}\nfunction isObject(item) {\n    return !!item && typeof item === 'object' && !Array.isArray(item);\n}\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\nfunction toCamelCase(str) {\n    return str\n        .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => index == 0 ? word.toLowerCase() : word.toUpperCase())\n        .replace(/\\s+|_|-|\\//g, '');\n}\nfunction isBrowser() {\n    return typeof window !== 'undefined';\n}\nfunction isNil(value) {\n    return value === null || value === undefined;\n}\nfunction isDefined(value) {\n    return isNil(value) === false;\n}\nfunction toNumber(value) {\n    if (isNumber(value))\n        return value;\n    if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n        return Number(value);\n    }\n    return null;\n}\nfunction isScopeObject(item) {\n    return item && typeof item.scope === 'string';\n}\nfunction hasInlineLoader(item) {\n    return item && isObject(item.loader);\n}\nfunction unflatten(obj) {\n    return unflatten$1(obj);\n}\nfunction flatten(obj) {\n    return flatten$1(obj, { safe: true });\n}\n\nconst TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n    providedIn: 'root',\n    factory: () => {\n        return { defaultLang: 'en' };\n    },\n});\nconst defaultConfig = {\n    defaultLang: 'en',\n    reRenderOnLangChange: false,\n    prodMode: false,\n    failedRetries: 2,\n    availableLangs: [],\n    missingHandler: {\n        logMissingKey: true,\n        useFallbackTranslation: false,\n        allowEmpty: false,\n    },\n    flatten: {\n        aot: false,\n    },\n    interpolation: ['{{', '}}'],\n};\n/**\n * Sets up TranslocoConfig object.\n *\n * @param config The partial config object to load, this is optional,\n * will be spread after defaultConfig.\n */\nfunction translocoConfig(config = defaultConfig) {\n    return { ...defaultConfig, ...config };\n}\n\nconst TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\nclass DefaultTranspiler {\n    constructor(userConfig) {\n        this.interpolationMatcher = resolveMatcher(userConfig);\n    }\n    transpile(value, params = {}, translation, key) {\n        if (isString(value)) {\n            return value.replace(this.interpolationMatcher, (_, match) => {\n                match = match.trim();\n                if (isDefined(params[match])) {\n                    return params[match];\n                }\n                return isDefined(translation[match])\n                    ? this.transpile(translation[match], params, translation, key)\n                    : '';\n            });\n        }\n        else if (params) {\n            if (isObject(value)) {\n                value = this.handleObject(value, params, translation, key);\n            }\n            else if (Array.isArray(value)) {\n                value = this.handleArray(value, params, translation, key);\n            }\n        }\n        return value;\n    }\n    /**\n     *\n     * @example\n     *\n     * const en = {\n     *  a: {\n     *    b: {\n     *      c: \"Hello {{ value }}\"\n     *    }\n     *  }\n     * }\n     *\n     * const params =  {\n     *  \"b.c\": { value: \"Transloco \"}\n     * }\n     *\n     * service.selectTranslate('a', params);\n     *\n     * // the first param will be the result of `en.a`.\n     * // the second param will be `params`.\n     * parser.transpile(value, params, {});\n     *\n     *\n     */\n    handleObject(value, params = {}, translation, key) {\n        let result = value;\n        Object.keys(params).forEach((p) => {\n            // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n            const v = getValue(result, p);\n            // get the params of \"b.c\" => { value: \"Transloco\" }\n            const getParams = getValue(params, p);\n            // transpile the value => \"Hello Transloco\"\n            const transpiled = this.transpile(v, getParams, translation, key);\n            // set \"b.c\" to `transpiled`\n            result = setValue(result, p, transpiled);\n        });\n        return result;\n    }\n    handleArray(value, params = {}, translation, key) {\n        return value.map((v) => this.transpile(v, params, translation, key));\n    }\n}\nDefaultTranspiler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultTranspiler, deps: [{ token: TRANSLOCO_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\nDefaultTranspiler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultTranspiler });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultTranspiler, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_CONFIG]\n                }] }]; } });\nfunction resolveMatcher(userConfig) {\n    const [start, end] = userConfig && userConfig.interpolation\n        ? userConfig.interpolation\n        : defaultConfig.interpolation;\n    return new RegExp(`${start}(.*?)${end}`, 'g');\n}\nfunction getFunctionArgs(argsString) {\n    const splitted = argsString ? argsString.split(',') : [];\n    const args = [];\n    for (let i = 0; i < splitted.length; i++) {\n        let value = splitted[i].trim();\n        while (value[value.length - 1] === '\\\\') {\n            i++;\n            value = value.replace('\\\\', ',') + splitted[i];\n        }\n        args.push(value);\n    }\n    return args;\n}\nclass FunctionalTranspiler extends DefaultTranspiler {\n    constructor(injector) {\n        super();\n        this.injector = injector;\n    }\n    transpile(value, params = {}, translation, key) {\n        let transpiled = value;\n        if (isString(value)) {\n            transpiled = value.replace(/\\[\\[\\s*(\\w+)\\((.*)\\)\\s*]]/g, (match, functionName, args) => {\n                try {\n                    const func = this.injector.get(functionName);\n                    return func.transpile(...getFunctionArgs(args));\n                }\n                catch (e) {\n                    let message = `There is an error in: '${value}'. \n                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;\n                    if (e.message.includes('NullInjectorError')) {\n                        message = `You are using the '${functionName}' function in your translation but no provider was found!`;\n                    }\n                    throw new Error(message);\n                }\n            });\n        }\n        return super.transpile(transpiled, params, translation, key);\n    }\n}\nFunctionalTranspiler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: FunctionalTranspiler, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });\nFunctionalTranspiler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: FunctionalTranspiler });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: FunctionalTranspiler, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });\n\nconst TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\nclass DefaultHandler {\n    handle(key, config) {\n        if (config.missingHandler.logMissingKey && !config.prodMode) {\n            const msg = `Missing translation for '${key}'`;\n            console.warn(`%c ${msg}`, 'font-size: 12px; color: red');\n        }\n        return key;\n    }\n}\nDefaultHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nDefaultHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultHandler });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultHandler, decorators: [{\n            type: Injectable\n        }] });\n\nconst TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\nclass DefaultInterceptor {\n    preSaveTranslation(translation) {\n        return translation;\n    }\n    preSaveTranslationKey(_, value) {\n        return value;\n    }\n}\nDefaultInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultInterceptor, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nDefaultInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultInterceptor });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultInterceptor, decorators: [{\n            type: Injectable\n        }] });\n\nconst TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken('TRANSLOCO_FALLBACK_STRATEGY');\nclass DefaultFallbackStrategy {\n    constructor(userConfig) {\n        this.userConfig = userConfig;\n    }\n    getNextLangs() {\n        const fallbackLang = this.userConfig.fallbackLang;\n        if (!fallbackLang) {\n            throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n        }\n        return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n    }\n}\nDefaultFallbackStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultFallbackStrategy, deps: [{ token: TRANSLOCO_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });\nDefaultFallbackStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultFallbackStrategy });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: DefaultFallbackStrategy, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_CONFIG]\n                }] }]; } });\n\nfunction mergeConfig(defaultConfig, userConfig) {\n    return {\n        ...defaultConfig,\n        ...userConfig,\n        missingHandler: {\n            ...defaultConfig.missingHandler,\n            ...userConfig.missingHandler,\n        },\n        flatten: {\n            ...defaultConfig.flatten,\n            ...userConfig.flatten,\n        },\n    };\n}\n\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\nfunction getScopeFromLang(lang) {\n    if (!lang) {\n        return '';\n    }\n    const split = lang.split('/');\n    split.pop();\n    return split.join('/');\n}\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\nfunction getLangFromScope(lang) {\n    if (!lang) {\n        return '';\n    }\n    return lang.split('/').pop();\n}\n/**\n * @example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n */\nfunction getPipeValue(str, value, char = '|') {\n    if (isString(str)) {\n        const splitted = str.split(char);\n        const lastItem = splitted.pop();\n        return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n    }\n    return [false, ''];\n}\nfunction shouldListenToLangChanges(service, lang) {\n    const [hasStatic] = getPipeValue(lang, 'static');\n    if (!hasStatic) {\n        // If we didn't get 'lang|static' check if it's set in the global level\n        return !!service.config.reRenderOnLangChange;\n    }\n    // We have 'lang|static' so don't listen to lang changes\n    return false;\n}\nfunction listenOrNotOperator(listenToLangChange) {\n    return listenToLangChange ? (source) => source : take(1);\n}\nfunction prependScope(inlineLoader, scope) {\n    return Object.keys(inlineLoader).reduce((acc, lang) => {\n        acc[`${scope}/${lang}`] = inlineLoader[lang];\n        return acc;\n    }, {});\n}\nfunction resolveInlineLoader(providerScope, scope) {\n    return hasInlineLoader(providerScope)\n        ? prependScope(providerScope.loader, scope)\n        : undefined;\n}\nfunction getEventPayload(lang) {\n    return {\n        scope: getScopeFromLang(lang) || null,\n        langName: getLangFromScope(lang),\n    };\n}\n\nfunction resolveLoader(options) {\n    const { path, inlineLoader, mainLoader, data } = options;\n    if (inlineLoader) {\n        const pathLoader = inlineLoader[path];\n        if (isFunction(pathLoader) === false) {\n            throw `You're using an inline loader but didn't provide a loader for ${path}`;\n        }\n        return inlineLoader[path]().then((res) => res.default ? res.default : res);\n    }\n    return mainLoader.getTranslation(path, data);\n}\n\nfunction getFallbacksLoaders({ mainLoader, path, data, fallbackPath, inlineLoader, }) {\n    const paths = fallbackPath ? [path, fallbackPath] : [path];\n    return paths.map((path) => {\n        const loader = resolveLoader({ path, mainLoader, inlineLoader, data });\n        return from(loader).pipe(map((translation) => ({\n            translation,\n            lang: path,\n        })));\n    });\n}\n\nlet service;\nfunction translate(key, params = {}, lang) {\n    return service.translate(key, params, lang);\n}\nfunction translateObject(key, params = {}, lang) {\n    return service.translateObject(key, params, lang);\n}\nclass TranslocoService {\n    constructor(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {\n        this.loader = loader;\n        this.parser = parser;\n        this.missingHandler = missingHandler;\n        this.interceptor = interceptor;\n        this.userConfig = userConfig;\n        this.fallbackStrategy = fallbackStrategy;\n        this.subscription = null;\n        this.translations = new Map();\n        this.cache = new Map();\n        this.defaultLang = '';\n        this.availableLangs = [];\n        this.isResolvedMissingOnce = false;\n        this.failedLangs = new Set();\n        this.events = new Subject();\n        this.events$ = this.events.asObservable();\n        if (!this.loader) {\n            this.loader = new DefaultLoader(this.translations);\n        }\n        service = this;\n        this.mergedConfig = mergeConfig(defaultConfig, this.userConfig);\n        this.setAvailableLangs(this.mergedConfig.availableLangs || []);\n        this.setFallbackLangForMissingTranslation(this.mergedConfig);\n        this.setDefaultLang(this.mergedConfig.defaultLang);\n        this.lang = new BehaviorSubject(this.getDefaultLang());\n        // Don't use distinctUntilChanged as we need the ability to update\n        // the value when using setTranslation or setTranslationKeys\n        this.langChanges$ = this.lang.asObservable();\n        /**\n         * When we have a failure, we want to define the next language that succeeded as the active\n         */\n        this.subscription = this.events$.subscribe((e) => {\n            if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n                this.setActiveLang(e.payload.langName);\n            }\n        });\n    }\n    get config() {\n        return this.mergedConfig;\n    }\n    getDefaultLang() {\n        return this.defaultLang;\n    }\n    setDefaultLang(lang) {\n        this.defaultLang = lang;\n    }\n    getActiveLang() {\n        return this.lang.getValue();\n    }\n    setActiveLang(lang) {\n        this.parser.onLangChanged?.(lang);\n        this.lang.next(lang);\n        this.events.next({\n            type: 'langChanged',\n            payload: getEventPayload(lang),\n        });\n        return this;\n    }\n    setAvailableLangs(langs) {\n        this.availableLangs = langs;\n    }\n    /**\n     * Gets the available languages.\n     *\n     * @returns\n     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n     * depending on how the available languages are set in your module.\n     */\n    getAvailableLangs() {\n        return this.availableLangs;\n    }\n    load(path, options = {}) {\n        const cached = this.cache.get(path);\n        if (cached) {\n            return cached;\n        }\n        let loadTranslation;\n        const isScope = this._isLangScoped(path);\n        let scope;\n        if (isScope) {\n            scope = getScopeFromLang(path);\n        }\n        const loadersOptions = {\n            path,\n            mainLoader: this.loader,\n            inlineLoader: options.inlineLoader,\n            data: isScope ? { scope: scope } : undefined,\n        };\n        if (this.useFallbackTranslation(path)) {\n            // if the path is scope the fallback should be `scope/fallbackLang`;\n            const fallback = isScope\n                ? `${scope}/${this.firstFallbackLang}`\n                : this.firstFallbackLang;\n            const loaders = getFallbacksLoaders({\n                ...loadersOptions,\n                fallbackPath: fallback,\n            });\n            loadTranslation = forkJoin(loaders);\n        }\n        else {\n            const loader = resolveLoader(loadersOptions);\n            loadTranslation = from(loader);\n        }\n        const load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap((translation) => {\n            if (Array.isArray(translation)) {\n                translation.forEach((t) => {\n                    this.handleSuccess(t.lang, t.translation);\n                    // Save the fallback in cache so we'll not create a redundant request\n                    if (t.lang !== path) {\n                        this.cache.set(t.lang, of({}));\n                    }\n                });\n                return;\n            }\n            this.handleSuccess(path, translation);\n        }), catchError((error) => {\n            if (!this.mergedConfig.prodMode) {\n                console.error(`Error while trying to load \"${path}\"`, error);\n            }\n            return this.handleFailure(path, options);\n        }), shareReplay(1));\n        this.cache.set(path, load$);\n        return load$;\n    }\n    /**\n     * Gets the instant translated value of a key\n     *\n     * @example\n     *\n     * translate<string>('hello')\n     * translate('hello', { value: 'value' })\n     * translate<string[]>(['hello', 'key'])\n     * translate('hello', { }, 'en')\n     * translate('scope.someKey', { }, 'en')\n     */\n    translate(key, params = {}, lang = this.getActiveLang()) {\n        if (!key)\n            return key;\n        const { scope, resolveLang } = this.resolveLangAndScope(lang);\n        if (Array.isArray(key)) {\n            return key.map((k) => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang));\n        }\n        key = scope ? `${scope}.${key}` : key;\n        const translation = this.getTranslation(resolveLang);\n        const value = translation[key];\n        if (!value) {\n            return this._handleMissingKey(key, value, params);\n        }\n        return this.parser.transpile(value, params, translation, key);\n    }\n    /**\n     * Gets the translated value of a key as observable\n     *\n     * @example\n     *\n     * selectTranslate<string>('hello').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n     *\n     */\n    selectTranslate(key, params, lang, _isObject = false) {\n        let inlineLoader;\n        const load = (lang, options) => this.load(lang, options).pipe(map(() => _isObject\n            ? this.translateObject(key, params, lang)\n            : this.translate(key, params, lang)));\n        if (isNil(lang)) {\n            return this.langChanges$.pipe(switchMap((lang) => load(lang)));\n        }\n        if (isScopeObject(lang)) {\n            // it's a scope object.\n            const providerScope = lang;\n            lang = providerScope.scope;\n            inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);\n        }\n        lang = lang;\n        if (this.isLang(lang) || this.isScopeWithLang(lang)) {\n            return load(lang);\n        }\n        // it's a scope\n        const scope = lang;\n        return this.langChanges$.pipe(switchMap((lang) => load(`${scope}/${lang}`, { inlineLoader })));\n    }\n    /**\n     * Whether the scope with lang\n     *\n     * @example\n     *\n     * todos/en => true\n     * todos => false\n     */\n    isScopeWithLang(lang) {\n        return this.isLang(getLangFromScope(lang));\n    }\n    translateObject(key, params = {}, lang = this.getActiveLang()) {\n        if (isString(key) || Array.isArray(key)) {\n            const { resolveLang, scope } = this.resolveLangAndScope(lang);\n            if (Array.isArray(key)) {\n                return key.map((k) => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang));\n            }\n            const translation = this.getTranslation(resolveLang);\n            key = scope ? `${scope}.${key}` : key;\n            const value = unflatten(this.getObjectByKey(translation, key));\n            /* If an empty object was returned we want to try and translate the key as a string and not an object */\n            return isEmpty(value)\n                ? this.translate(key, params, lang)\n                : this.parser.transpile(value, params, translation, key);\n        }\n        const translations = [];\n        for (const [_key, _params] of this.getEntries(key)) {\n            translations.push(this.translateObject(_key, _params, lang));\n        }\n        return translations;\n    }\n    selectTranslateObject(key, params, lang) {\n        if (isString(key) || Array.isArray(key)) {\n            return this.selectTranslate(key, params, lang, true);\n        }\n        const [[firstKey, firstParams], ...rest] = this.getEntries(key);\n        /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,\n         * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */\n        return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map((value) => {\n            const translations = [value];\n            for (const [_key, _params] of rest) {\n                translations.push(this.translateObject(_key, _params, lang));\n            }\n            return translations;\n        }));\n    }\n    getTranslation(langOrScope) {\n        if (langOrScope) {\n            if (this.isLang(langOrScope)) {\n                return this.translations.get(langOrScope) || {};\n            }\n            else {\n                // This is a scope, build the scope value from the translation object\n                const { scope, resolveLang } = this.resolveLangAndScope(langOrScope);\n                const translation = this.translations.get(resolveLang) || {};\n                return this.getObjectByKey(translation, scope);\n            }\n        }\n        return this.translations;\n    }\n    /**\n     * Gets an object of translations for a given language\n     *\n     * @example\n     *\n     * selectTranslation().subscribe() - will return the current lang translation\n     * selectTranslation('es').subscribe()\n     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\n     * selectTranslation('admin-page/es').subscribe()\n     */\n    selectTranslation(lang) {\n        let language$ = this.langChanges$;\n        if (lang) {\n            const scopeLangSpecified = getLangFromScope(lang) !== lang;\n            if (this.isLang(lang) || scopeLangSpecified) {\n                language$ = of(lang);\n            }\n            else {\n                language$ = this.langChanges$.pipe(map((currentLang) => `${lang}/${currentLang}`));\n            }\n        }\n        return language$.pipe(switchMap((language) => this.load(language).pipe(map(() => this.getTranslation(language)))));\n    }\n    /**\n     * Sets or merge a given translation object to current lang\n     *\n     * @example\n     *\n     * setTranslation({ ... })\n     * setTranslation({ ... }, 'en')\n     * setTranslation({ ... }, 'es', { merge: false } )\n     * setTranslation({ ... }, 'todos/en', { merge: false } )\n     */\n    setTranslation(translation, lang = this.getActiveLang(), options = {}) {\n        const defaults = { merge: true, emitChange: true };\n        const mergedOptions = { ...defaults, ...options };\n        const scope = getScopeFromLang(lang);\n        /**\n         * If this isn't a scope we use the whole translation as is\n         * otherwise we need to flat the scope and use it\n         */\n        let flattenScopeOrTranslation = translation;\n        // Merged the scoped language into the active language\n        if (scope) {\n            const key = this.getMappedScope(scope);\n            flattenScopeOrTranslation = flatten({ [key]: translation });\n        }\n        const currentLang = scope ? getLangFromScope(lang) : lang;\n        const mergedTranslation = {\n            ...(mergedOptions.merge && this.getTranslation(currentLang)),\n            ...flattenScopeOrTranslation,\n        };\n        const flattenTranslation = this.mergedConfig.flatten.aot\n            ? mergedTranslation\n            : flatten(mergedTranslation);\n        const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n        this.translations.set(currentLang, withHook);\n        mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n    }\n    /**\n     * Sets translation key with given value\n     *\n     * @example\n     *\n     * setTranslationKey('key', 'value')\n     * setTranslationKey('key.nested', 'value')\n     * setTranslationKey('key.nested', 'value', 'en')\n     * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )\n     */\n    setTranslationKey(key, value, \n    // Todo: Add the lang to the options in v3\n    lang = this.getActiveLang(), options = {}) {\n        const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n        const newValue = {\n            [key]: withHook,\n        };\n        this.setTranslation(newValue, lang, { ...options, merge: true });\n    }\n    /**\n     * Sets the fallback lang for the currently active language\n     * @param fallbackLang\n     */\n    setFallbackLangForMissingTranslation({ fallbackLang, }) {\n        const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n        if (fallbackLang && this.useFallbackTranslation(lang)) {\n            this.firstFallbackLang = lang;\n        }\n    }\n    /**\n     * @internal\n     */\n    _handleMissingKey(key, value, params) {\n        if (this.config.missingHandler.allowEmpty && value === '') {\n            return '';\n        }\n        if (!this.isResolvedMissingOnce && this.useFallbackTranslation()) {\n            // We need to set it to true to prevent a loop\n            this.isResolvedMissingOnce = true;\n            const fallbackValue = this.translate(key, params, this.firstFallbackLang);\n            this.isResolvedMissingOnce = false;\n            return fallbackValue;\n        }\n        return this.missingHandler.handle(key, this.getMissingHandlerData(), params);\n    }\n    /**\n     * @internal\n     */\n    _isLangScoped(lang) {\n        return this.getAvailableLangsIds().indexOf(lang) === -1;\n    }\n    /**\n     * Checks if a given string is one of the specified available languages.\n     * @returns\n     * True if the given string is an available language.\n     * False if the given string is not an available language.\n     */\n    isLang(lang) {\n        return this.getAvailableLangsIds().indexOf(lang) !== -1;\n    }\n    /**\n     * @internal\n     *\n     * We always want to make sure the global lang is loaded\n     * before loading the scope since you can access both via the pipe/directive.\n     */\n    _loadDependencies(path, inlineLoader) {\n        const mainLang = getLangFromScope(path);\n        if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n            return combineLatest(this.load(mainLang), this.load(path, { inlineLoader }));\n        }\n        return this.load(path, { inlineLoader });\n    }\n    /**\n     * @internal\n     */\n    _completeScopeWithLang(langOrScope) {\n        if (this._isLangScoped(langOrScope) &&\n            !this.isLang(getLangFromScope(langOrScope))) {\n            return `${langOrScope}/${this.getActiveLang()}`;\n        }\n        return langOrScope;\n    }\n    /**\n     * @internal\n     */\n    _setScopeAlias(scope, alias) {\n        if (!this.mergedConfig.scopeMapping) {\n            this.mergedConfig.scopeMapping = {};\n        }\n        this.mergedConfig.scopeMapping[scope] = alias;\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n            // callback within its `destination` property, preventing classes from being GC'd.\n            this.subscription = null;\n        }\n        // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.\n        // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from\n        // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created\n        // and destroyed per each HTTP request, but any service is not getting GC'd.\n        this.cache.clear();\n    }\n    isLoadedTranslation(lang) {\n        return size(this.getTranslation(lang));\n    }\n    getAvailableLangsIds() {\n        const first = this.getAvailableLangs()[0];\n        if (isString(first)) {\n            return this.getAvailableLangs();\n        }\n        return this.getAvailableLangs().map((l) => l.id);\n    }\n    getMissingHandlerData() {\n        return {\n            ...this.config,\n            activeLang: this.getActiveLang(),\n            availableLangs: this.availableLangs,\n            defaultLang: this.defaultLang,\n        };\n    }\n    /**\n     * Use a fallback translation set for missing keys of the primary language\n     * This is unrelated to the fallback language (which changes the active language)\n     */\n    useFallbackTranslation(lang) {\n        return (this.config.missingHandler.useFallbackTranslation &&\n            lang !== this.firstFallbackLang);\n    }\n    handleSuccess(lang, translation) {\n        this.setTranslation(translation, lang, { emitChange: false });\n        this.events.next({\n            wasFailure: !!this.failedLangs.size,\n            type: 'translationLoadSuccess',\n            payload: getEventPayload(lang),\n        });\n        this.failedLangs.forEach((l) => this.cache.delete(l));\n        this.failedLangs.clear();\n    }\n    handleFailure(lang, loadOptions) {\n        // When starting to load a first choice language, initialize\n        // the failed counter and resolve the fallback langs.\n        if (isNil(loadOptions.failedCounter)) {\n            loadOptions.failedCounter = 0;\n            if (!loadOptions.fallbackLangs) {\n                loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);\n            }\n        }\n        const splitted = lang.split('/');\n        const fallbacks = loadOptions.fallbackLangs;\n        const nextLang = fallbacks[loadOptions.failedCounter];\n        this.failedLangs.add(lang);\n        // This handles the case where a loaded fallback language is requested again\n        if (this.cache.has(nextLang)) {\n            this.handleSuccess(nextLang, this.getTranslation(nextLang));\n            return EMPTY;\n        }\n        const isFallbackLang = nextLang === splitted[splitted.length - 1];\n        if (!nextLang || isFallbackLang) {\n            let msg = `Unable to load translation and all the fallback languages`;\n            if (splitted.length > 1) {\n                msg += `, did you misspelled the scope name?`;\n            }\n            throw new Error(msg);\n        }\n        let resolveLang = nextLang;\n        // if it's scoped lang\n        if (splitted.length > 1) {\n            // We need to resolve it to:\n            // todos/langNotExists => todos/nextLang\n            splitted[splitted.length - 1] = nextLang;\n            resolveLang = splitted.join('/');\n        }\n        loadOptions.failedCounter++;\n        this.events.next({\n            type: 'translationLoadFailure',\n            payload: getEventPayload(lang),\n        });\n        return this.load(resolveLang, loadOptions);\n    }\n    getMappedScope(scope) {\n        const { scopeMapping = {} } = this.config;\n        return scopeMapping[scope] || toCamelCase(scope);\n    }\n    /**\n     * If lang is scope we need to check the following cases:\n     * todos/es => in this case we should take `es` as lang\n     * todos => in this case we should set the active lang as lang\n     */\n    resolveLangAndScope(lang) {\n        let resolveLang = lang;\n        let scope;\n        if (this._isLangScoped(lang)) {\n            // en for example\n            const langFromScope = getLangFromScope(lang);\n            // en is lang\n            const hasLang = this.isLang(langFromScope);\n            // take en\n            resolveLang = hasLang ? langFromScope : this.getActiveLang();\n            // find the scope\n            scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n        }\n        return { scope, resolveLang };\n    }\n    getObjectByKey(translation, key) {\n        const result = {};\n        const prefix = `${key}.`;\n        for (const currentKey in translation) {\n            if (currentKey.startsWith(prefix)) {\n                result[currentKey.replace(prefix, '')] = translation[currentKey];\n            }\n        }\n        return result;\n    }\n    getEntries(key) {\n        return key instanceof Map ? key.entries() : Object.entries(key);\n    }\n}\nTranslocoService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoService, deps: [{ token: TRANSLOCO_LOADER, optional: true }, { token: TRANSLOCO_TRANSPILER }, { token: TRANSLOCO_MISSING_HANDLER }, { token: TRANSLOCO_INTERCEPTOR }, { token: TRANSLOCO_CONFIG }, { token: TRANSLOCO_FALLBACK_STRATEGY }], target: i0.ɵɵFactoryTarget.Injectable });\nTranslocoService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoService, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_LOADER]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_TRANSPILER]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_MISSING_HANDLER]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_INTERCEPTOR]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_CONFIG]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_FALLBACK_STRATEGY]\n                }] }]; } });\n\nclass TranslocoLoaderComponent {\n}\nTranslocoLoaderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoLoaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\nTranslocoLoaderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.3.10\", type: TranslocoLoaderComponent, selector: \"ng-component\", inputs: { html: \"html\" }, ngImport: i0, template: `\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\n  `, isInline: true });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoLoaderComponent, decorators: [{\n            type: Component,\n            args: [{\n                    template: `\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\n  `,\n                }]\n        }], propDecorators: { html: [{\n                type: Input\n            }] } });\n\nclass TemplateHandler {\n    constructor(view, vcr) {\n        this.view = view;\n        this.vcr = vcr;\n        this.injector = this.vcr.injector;\n    }\n    attachView() {\n        if (this.view instanceof TemplateRef) {\n            this.vcr.createEmbeddedView(this.view);\n        }\n        else if (isString(this.view)) {\n            const componentRef = this.createComponent(TranslocoLoaderComponent);\n            componentRef.instance.html = this.view;\n            componentRef.hostView.detectChanges();\n        }\n        else {\n            this.createComponent(this.view);\n        }\n    }\n    detachView() {\n        this.vcr.clear();\n    }\n    createComponent(cmp) {\n        const cfr = this.injector.get(ComponentFactoryResolver);\n        const factory = cfr.resolveComponentFactory(cmp);\n        return this.vcr.createComponent(factory);\n    }\n}\n\nconst TRANSLOCO_LANG = new InjectionToken('TRANSLOCO_LANG');\n\nconst TRANSLOCO_LOADING_TEMPLATE = new InjectionToken('TRANSLOCO_LOADING_TEMPLATE');\n\nconst TRANSLOCO_SCOPE = new InjectionToken('TRANSLOCO_SCOPE');\n\nclass LangResolver {\n    constructor() {\n        this.initialized = false;\n    }\n    // inline => provider => active\n    resolve({ inline, provider, active }) {\n        let lang = active;\n        /**\n         * When the user changes the lang we need to update\n         * the view. Otherwise, the lang will remain the inline/provided lang\n         */\n        if (this.initialized) {\n            lang = active;\n            return lang;\n        }\n        if (provider) {\n            const [, extracted] = getPipeValue(provider, 'static');\n            lang = extracted;\n        }\n        if (inline) {\n            const [, extracted] = getPipeValue(inline, 'static');\n            lang = extracted;\n        }\n        this.initialized = true;\n        return lang;\n    }\n    /**\n     *\n     * Resolve the lang\n     *\n     * @example\n     *\n     * resolveLangBasedOnScope('todos/en') => en\n     * resolveLangBasedOnScope('en') => en\n     *\n     */\n    resolveLangBasedOnScope(lang) {\n        const scope = getScopeFromLang(lang);\n        return scope ? getLangFromScope(lang) : lang;\n    }\n    /**\n     *\n     * Resolve the lang path for loading\n     *\n     * @example\n     *\n     * resolveLangPath('todos', 'en') => todos/en\n     * resolveLangPath('en') => en\n     *\n     */\n    resolveLangPath(lang, scope) {\n        return scope ? `${scope}/${lang}` : lang;\n    }\n}\n\nclass ScopeResolver {\n    constructor(translocoService) {\n        this.translocoService = translocoService;\n    }\n    // inline => provider\n    resolve({ inline, provider } = {\n        inline: undefined,\n        provider: undefined,\n    }) {\n        if (inline) {\n            return inline;\n        }\n        if (provider) {\n            if (isScopeObject(provider)) {\n                const { scope, alias = toCamelCase(scope) } = provider;\n                this.translocoService._setScopeAlias(scope, alias);\n                return scope;\n            }\n            return provider;\n        }\n        return undefined;\n    }\n}\n\nclass TranslocoDirective {\n    constructor(translocoService, tpl, providerScope, providerLang, providedLoadingTpl, vcr, cdr, host, renderer) {\n        this.translocoService = translocoService;\n        this.tpl = tpl;\n        this.providerScope = providerScope;\n        this.providerLang = providerLang;\n        this.providedLoadingTpl = providedLoadingTpl;\n        this.vcr = vcr;\n        this.cdr = cdr;\n        this.host = host;\n        this.renderer = renderer;\n        this.subscription = null;\n        this.translationMemo = {};\n        this.params = {};\n        // Whether we already rendered the view once\n        this.initialized = false;\n        this.langResolver = new LangResolver();\n        this.scopeResolver = new ScopeResolver(this.translocoService);\n        this.strategy = this.tpl === null ? 'attribute' : 'structural';\n    }\n    static ngTemplateContextGuard(dir, ctx) {\n        return true;\n    }\n    ngOnInit() {\n        const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);\n        this.subscription = this.translocoService.langChanges$\n            .pipe(switchMap((activeLang) => {\n            const lang = this.langResolver.resolve({\n                inline: this.inlineLang,\n                provider: this.providerLang,\n                active: activeLang,\n            });\n            return Array.isArray(this.providerScope)\n                ? forkJoin(this.providerScope.map((providerScope) => this.resolveScope(lang, providerScope)))\n                : this.resolveScope(lang, this.providerScope);\n        }), listenOrNotOperator(listenToLangChange))\n            .subscribe(() => {\n            this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);\n            this.strategy === 'attribute'\n                ? this.attributeStrategy()\n                : this.structuralStrategy(this.currentLang, this.inlineRead);\n            this.cdr.markForCheck();\n            this.initialized = true;\n        });\n        const loadingTpl = this.getLoadingTpl();\n        if (!this.initialized && loadingTpl) {\n            this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);\n            this.loaderTplHandler.attachView();\n        }\n    }\n    ngOnChanges(changes) {\n        // We need to support dynamic keys/params, so if this is not the first change CD cycle\n        // we need to run the function again in order to update the value\n        if (this.strategy === 'attribute') {\n            const notInit = Object.keys(changes).some((v) => !changes[v].firstChange);\n            notInit && this.attributeStrategy();\n        }\n    }\n    attributeStrategy() {\n        this.detachLoader();\n        this.renderer.setProperty(this.host.nativeElement, 'innerText', this.translocoService.translate(this.key, this.params, this.currentLang));\n    }\n    structuralStrategy(lang, read) {\n        this.translationMemo = {};\n        if (this.view) {\n            // when the lang changes we need to change the reference so Angular will update the view\n            this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n            this.view.context['currentLang'] = this.currentLang;\n        }\n        else {\n            this.detachLoader();\n            this.view = this.vcr.createEmbeddedView(this.tpl, {\n                $implicit: this.getTranslateFn(lang, read),\n                currentLang: this.currentLang,\n            });\n        }\n    }\n    getTranslateFn(lang, read) {\n        return (key, params) => {\n            const withRead = read ? `${read}.${key}` : key;\n            const withParams = params\n                ? `${withRead}${JSON.stringify(params)}`\n                : withRead;\n            if (Object.prototype.hasOwnProperty.call(this.translationMemo, withParams)) {\n                return this.translationMemo[withParams].value;\n            }\n            this.translationMemo[withParams] = {\n                params,\n                value: this.translocoService.translate(withRead, params, lang),\n            };\n            return this.translationMemo[withParams].value;\n        };\n    }\n    getLoadingTpl() {\n        return this.inlineTpl || this.providedLoadingTpl;\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n            // callback within its `destination` property, preventing classes from being GC'd.\n            this.subscription = null;\n        }\n    }\n    detachLoader() {\n        this.loaderTplHandler?.detachView();\n    }\n    resolveScope(lang, providerScope) {\n        const resolvedScope = this.scopeResolver.resolve({\n            inline: this.inlineScope,\n            provider: providerScope,\n        });\n        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n        const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n        return this.translocoService._loadDependencies(this.path, inlineLoader);\n    }\n}\nTranslocoDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoDirective, deps: [{ token: TranslocoService }, { token: i0.TemplateRef, optional: true }, { token: TRANSLOCO_SCOPE, optional: true }, { token: TRANSLOCO_LANG, optional: true }, { token: TRANSLOCO_LOADING_TEMPLATE, optional: true }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });\nTranslocoDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.10\", type: TranslocoDirective, selector: \"[transloco]\", inputs: { key: [\"transloco\", \"key\"], params: [\"translocoParams\", \"params\"], inlineScope: [\"translocoScope\", \"inlineScope\"], inlineRead: [\"translocoRead\", \"inlineRead\"], inlineLang: [\"translocoLang\", \"inlineLang\"], inlineTpl: [\"translocoLoadingTpl\", \"inlineTpl\"] }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[transloco]',\n                }]\n        }], ctorParameters: function () { return [{ type: TranslocoService }, { type: i0.TemplateRef, decorators: [{\n                    type: Optional\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_SCOPE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_LANG]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_LOADING_TEMPLATE]\n                }] }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { key: [{\n                type: Input,\n                args: ['transloco']\n            }], params: [{\n                type: Input,\n                args: ['translocoParams']\n            }], inlineScope: [{\n                type: Input,\n                args: ['translocoScope']\n            }], inlineRead: [{\n                type: Input,\n                args: ['translocoRead']\n            }], inlineLang: [{\n                type: Input,\n                args: ['translocoLang']\n            }], inlineTpl: [{\n                type: Input,\n                args: ['translocoLoadingTpl']\n            }] } });\n\nclass TranslocoPipe {\n    constructor(translocoService, providerScope, providerLang, cdr) {\n        this.translocoService = translocoService;\n        this.providerScope = providerScope;\n        this.providerLang = providerLang;\n        this.cdr = cdr;\n        this.subscription = null;\n        this.lastValue = '';\n        this.langResolver = new LangResolver();\n        this.scopeResolver = new ScopeResolver(this.translocoService);\n    }\n    // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311\n    // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488\n    transform(key, params, inlineLang) {\n        if (!key) {\n            return key;\n        }\n        const keyName = params ? `${key}${JSON.stringify(params)}` : key;\n        if (keyName === this.lastKey) {\n            return this.lastValue;\n        }\n        this.lastKey = keyName;\n        this.subscription?.unsubscribe();\n        const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || inlineLang);\n        this.subscription = this.translocoService.langChanges$\n            .pipe(switchMap((activeLang) => {\n            const lang = this.langResolver.resolve({\n                inline: inlineLang,\n                provider: this.providerLang,\n                active: activeLang,\n            });\n            return Array.isArray(this.providerScope)\n                ? forkJoin(this.providerScope.map((providerScope) => this.resolveScope(lang, providerScope)))\n                : this.resolveScope(lang, this.providerScope);\n        }), listenOrNotOperator(listenToLangChange))\n            .subscribe(() => this.updateValue(key, params));\n        return this.lastValue;\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n            // callback within its `destination` property, preventing classes from being GC'd.\n            this.subscription = null;\n        }\n    }\n    updateValue(key, params) {\n        const lang = this.langResolver.resolveLangBasedOnScope(this.path);\n        this.lastValue = this.translocoService.translate(key, params, lang);\n        this.cdr.markForCheck();\n    }\n    resolveScope(lang, providerScope) {\n        const resolvedScope = this.scopeResolver.resolve({\n            inline: undefined,\n            provider: providerScope,\n        });\n        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n        const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n        return this.translocoService._loadDependencies(this.path, inlineLoader);\n    }\n}\nTranslocoPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoPipe, deps: [{ token: TranslocoService }, { token: TRANSLOCO_SCOPE, optional: true }, { token: TRANSLOCO_LANG, optional: true }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Pipe });\nTranslocoPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoPipe, name: \"transloco\", pure: false });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoPipe, decorators: [{\n            type: Pipe,\n            args: [{\n                    name: 'transloco',\n                    pure: false,\n                }]\n        }], ctorParameters: function () { return [{ type: TranslocoService }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_SCOPE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TRANSLOCO_LANG]\n                }] }, { type: i0.ChangeDetectorRef }]; } });\n\nconst defaultProviders = [\n    {\n        provide: TRANSLOCO_TRANSPILER,\n        useClass: DefaultTranspiler,\n        deps: [TRANSLOCO_CONFIG],\n    },\n    {\n        provide: TRANSLOCO_MISSING_HANDLER,\n        useClass: DefaultHandler,\n    },\n    {\n        provide: TRANSLOCO_INTERCEPTOR,\n        useClass: DefaultInterceptor,\n    },\n    {\n        provide: TRANSLOCO_FALLBACK_STRATEGY,\n        useClass: DefaultFallbackStrategy,\n        deps: [TRANSLOCO_CONFIG],\n    },\n];\nclass TranslocoModule {\n}\nTranslocoModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nTranslocoModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoModule, declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent], exports: [TranslocoDirective, TranslocoPipe] });\nTranslocoModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoModule, providers: [defaultProviders] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent],\n                    providers: [defaultProviders],\n                    exports: [TranslocoDirective, TranslocoPipe]\n                }]\n        }] });\n\nconst TRANSLOCO_TEST_LANGS = new InjectionToken('TRANSLOCO_TEST_LANGS - Available testing languages');\nconst TRANSLOCO_TEST_OPTIONS = new InjectionToken('TRANSLOCO_TEST_OPTIONS - Testing options');\nclass TestingLoader {\n    constructor(langs) {\n        this.langs = langs;\n    }\n    getTranslation(lang) {\n        return of(this.langs[lang]);\n    }\n}\nTestingLoader.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TestingLoader, deps: [{ token: TRANSLOCO_TEST_LANGS }], target: i0.ɵɵFactoryTarget.Injectable });\nTestingLoader.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TestingLoader });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TestingLoader, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [TRANSLOCO_TEST_LANGS]\n                }] }]; } });\nfunction initTranslocoService(service, langs = {}, options) {\n    const preloadAllLangs = () => options.preloadLangs\n        ? Promise.all(Object.keys(langs).map((lang) => service.load(lang).toPromise()))\n        : Promise.resolve();\n    return preloadAllLangs;\n}\nclass TranslocoTestingModule {\n    static forRoot(options) {\n        return {\n            ngModule: TranslocoTestingModule,\n            providers: [\n                {\n                    provide: TRANSLOCO_TEST_LANGS,\n                    useValue: options.langs,\n                },\n                {\n                    provide: TRANSLOCO_TEST_OPTIONS,\n                    useValue: options,\n                },\n                {\n                    provide: APP_INITIALIZER,\n                    useFactory: initTranslocoService,\n                    deps: [\n                        TranslocoService,\n                        TRANSLOCO_TEST_LANGS,\n                        TRANSLOCO_TEST_OPTIONS,\n                    ],\n                    multi: true,\n                },\n                {\n                    provide: TRANSLOCO_LOADER,\n                    useClass: TestingLoader,\n                },\n                defaultProviders,\n                {\n                    provide: TRANSLOCO_CONFIG,\n                    useValue: translocoConfig({\n                        prodMode: true,\n                        missingHandler: { logMissingKey: false },\n                        ...options.translocoConfig,\n                    }),\n                },\n            ],\n        };\n    }\n}\nTranslocoTestingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoTestingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nTranslocoTestingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoTestingModule, exports: [TranslocoModule] });\nTranslocoTestingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoTestingModule, imports: [TranslocoModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.10\", ngImport: i0, type: TranslocoTestingModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    exports: [TranslocoModule],\n                }]\n        }] });\n\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n */\nfunction getBrowserLang() {\n    let browserLang = getBrowserCultureLang();\n    if (!browserLang || !isBrowser()) {\n        return undefined;\n    }\n    if (browserLang.indexOf('-') !== -1) {\n        browserLang = browserLang.split('-')[0];\n    }\n    if (browserLang.indexOf('_') !== -1) {\n        browserLang = browserLang.split('_')[0];\n    }\n    return browserLang;\n}\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n */\nfunction getBrowserCultureLang() {\n    if (!isBrowser()) {\n        return '';\n    }\n    const navigator = window.navigator;\n    let browserCultureLang = navigator.languages ? navigator.languages[0] : null;\n    browserCultureLang =\n        browserCultureLang ||\n            navigator.language ||\n            navigator.browserLanguage ||\n            navigator.userLanguage;\n    return browserCultureLang;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DefaultFallbackStrategy, DefaultTranspiler, FunctionalTranspiler, TRANSLOCO_CONFIG, TRANSLOCO_FALLBACK_STRATEGY, TRANSLOCO_INTERCEPTOR, TRANSLOCO_LANG, TRANSLOCO_LOADER, TRANSLOCO_LOADING_TEMPLATE, TRANSLOCO_MISSING_HANDLER, TRANSLOCO_SCOPE, TRANSLOCO_TRANSPILER, TemplateHandler, TestingLoader, TranslocoDirective, TranslocoModule, TranslocoPipe, TranslocoService, TranslocoTestingModule, coerceArray, defaultConfig, defaultProviders, flatten, getBrowserCultureLang, getBrowserLang, getFunctionArgs, getLangFromScope, getPipeValue, getScopeFromLang, getValue, hasInlineLoader, isBrowser, isDefined, isEmpty, isFunction, isNil, isNumber, isObject, isScopeObject, isString, setValue, size, toCamelCase, toNumber, translate, translateObject, translocoConfig, unflatten };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}